<html>
	<head>
		<title>Starting Code for 1st Project 2017 - with lights and textures</title>
		<style>
		
		body {
			font-family: Monospace;
			background-color: #f0f0f0;
			margin: 0px;
			overflow: hidden;
		}
		
		canvas { 
			width: 100%; 
			height: 100%;
		}
	
	</style>
		<script src="../lib/three.min.js"></script>
		<script src="../lib/stats.min.js"></script>
		<script src="../lib/Coordinates.js"></script>
		<script src="../lib/OrbitControls.js"></script>

		<script src="Model.js"></script>
		<script src="AbstractAnimation.js"></script>
		<script src="RotationAnimation.js"></script>
		<script src="TranslationAnimation.js"></script>
		<script src="HeightMap.js"></script>
	</head>
	<body>
		
		<script>
		
		var scene, camera, renderer, controls, stats;
		
		function Start() {
			scene = new THREE.Scene();
			camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);

			renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.setClearColor(0xffddea);
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.gammaInput = true;
			renderer.gammaOutput = true;

			renderer.shadowMap.enabled = true;

			document.body.appendChild(renderer.domElement);
			
			camera.position.set(25, 25, 25);
			
/*
			var geometry = new THREE.BoxGeometry(1,1,1);
			var texture = THREE.ImageUtils.loadTexture('../textures/11635.jpg');
			var material = new THREE.MeshPhongMaterial({ map: texture });
			var cube = new THREE.Mesh(geometry, material);
			cube.castShadow = true;
			cube.receiveShadow = true;			
			scene.add(cube);
*/

			hemiLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 0.6);
			hemiLight.color.setHSL(0.6, 1, 0.6);
			hemiLight.groundColor.setHSL(0.095, 1, 0.75);
			hemiLight.position.set(0, 500, 0);
			scene.add(hemiLight);

			dirLight = new THREE.DirectionalLight(0xffffff, 1);
			dirLight.color.setHSL(.11, 1, 0.6);
			dirLight.position.set(-.2, .6, 1);
			dirLight.position.multiplyScalar(50);
			scene.add(dirLight);
			dirLight.castShadow = true;
			dirLight.shadow.mapSize.width = 1024;
			dirLight.shadow.mapSize.height = 1024;

			dirLight.shadow.camera.near = 3;
			dirLight.shadow.camera.left = -20;			
			dirLight.shadow.camera.right = 20;
			dirLight.shadow.camera.bottom = -20;
			dirLight.shadow.camera.top = 30;

			var target = new THREE.Object3D();
			target.position.set(30, 0, 0);
			target.updateMatrixWorld();
			dirLight.target = target;

			//var helper = new THREE.CameraHelper(dirLight.shadow.camera);
			//scene.add(helper);


			// GROUND

			var groundGeo = new THREE.PlaneBufferGeometry(10000, 10000);
			var groundMat = new THREE.MeshPhongMaterial({ color: 0xffffff, specular: 0x050505 });
			groundMat.color.setHSL(0.095, 1, 0.75);
			var ground = new THREE.Mesh(groundGeo, groundMat);
			ground.position.y = -0.5;
			ground.rotation.x = -Math.PI/2;
			scene.add(ground);
			
			stats = new Stats();
			stats.domElement.style.position = 'absolute';
			stats.domElement.style.top = '0px';
			document.body.appendChild(stats.domElement);
			
			// uncomment if you need to draw coordinate axes when building the scene
			//Coordinates.drawAllAxes();
			
			controls = new THREE.OrbitControls(camera);
			controls.addEventListener('change', Render);
						
		}

		function Update() {

			requestAnimationFrame(Update);

			// lanterns
			function invert(init_angle) {	// this accounts for the case in which the animation2
												// hasn't reached PI/4 (current angle) before
												// inversion
				var angle = animation2.getAngle();
				animation2.setInitAngle(init_angle);
				animation2.invert();
				animation2.begin();
				animation2.setAngle(angle_max-angle);
			}
			if (!wind) {
				if (Math.random() > .995) {
					time = Date.now();
					animation.setVelocity(3);
					invert(0);
					wind = true;
				}
			} else if (Date.now()-time > 2000) {
				animation.setVelocity(1);
				invert(angle_max);
				wind = false;
			}
			animation.perform();
			lantern.matrix.premultiply(matrix);
			lantern.matrixAutoUpdate = false;

			// clouds
			for(var j=0; j<nuv; j++) {                    					// un ciclo per ogni nuvola
            	if (clouds[j].position.z > -lim) {
                    clouds[j].position.z = clouds[j].position.z - step; 	// sposta la nuvola
            	} else {
                    clouds[j].position.z = lim;
                }
            }

			controls.update();
			//camera.lookAt(new THREE.Vector3(0, 0, 0));
			stats.update();
			Render();
		}

		function Render() {
			renderer.render(scene, camera);
		}
		
		
		Start();

	    // { --------------------------------------------------------- clouds
	    var nuv = 10;       // numero di nuvole
        var lim = 50;       // imposta da dove far partire e fin dove far arrivare la nuvola    
        var step = .1;		// imposta la velocità di scorrimento della nuvola, aumentare il moltiplicatore per diminuire la velocità
       
        var geometry = new THREE.BoxGeometry(5, 0.5, 5);    
        var material = new THREE.MeshBasicMaterial({ color: 0xd392b3 });
        clouds = new Array();
            
        for (var k=0; k < nuv; k++) {
            
            clouds[k] = new THREE.Mesh(geometry, material);
            clouds[k].position.y = 30;
            clouds[k].position.x = -lim+(Math.random()*lim*2);
            clouds[k].position.z = -lim+(Math.random()*lim*2);
            scene.add(clouds[k]);
        }
        // } --------------------------------------------------------- clouds
        
        var temple = drawTemple();
		scene.add(temple);

		var arch = drawArch();
		arch.position.x = 20;
		arch.scale.multiplyScalar(.5);
		scene.add(arch);

		// { --------------------------------------------------------- terrain test
		function applyRecursive(obj, prop, val) {
			for (var i = 0; i < obj.children.length; i++) {
				applyRecursive(obj.children[i], prop, val);
			}
			obj[prop] = val;
		}

		var material1 = new THREE.MeshPhongMaterial({ color: 0x201010 });	// terrain 1
		var material2 = new THREE.MeshPhongMaterial({ color: 0x201010 });	// terrain 2
		var material3 = new THREE.MeshPhongMaterial({ color: 0xa0a0a0 });	// stairs

		var img1 = new Image();
		img1.src = "../textures/terrain1.png";
		img1.onload = function () {
			var data = getHeightData(img1, 0.1);
			var terrain = heightMap(data, material1);
			terrain.scale.set(2, 1, 2);
			applyRecursive(terrain, 'receiveShadow', true);
			scene.add(terrain);
		};

		var img2 = new Image();
		img2.src = "../textures/terrain2.png";
		img2.onload = function () {
			var data = getHeightData(img2, 0.1);
			var terrain = heightMap(data, material2);
			var ypos = data.width*terrain.scale.x + 10;
			terrain.rotation.z = -Math.PI/2;
			terrain.position.set(0, ypos, 0);
			applyRecursive(terrain, 'castShadow', true);
			scene.add(terrain);

			temple.position.set(17, ypos-1.5, 6);
		};

		var img3 = new Image();
		img3.src = "../textures/stairs.png";
		img3.onload = function () {
			var data = getHeightData(img3, 0.1);
			var stairs = heightMap(data, material3);
			stairs.scale.z = .5;
			stairs.position.set(-.1, -.1, -.1);
			applyRecursive(stairs, 'receiveShadow', true);
			scene.add(stairs);
		};

		arch.position.set(23.4, 1, 30);
		applyRecursive(arch, 'castShadow', true);
		// } --------------------------------------------------------- terrain test


		// { --------------------------------------------------------- wind test
		var lantern = drawLantern();
		var matrix = (new THREE.Matrix4()).makeTranslation(0, 5, 20);
		matrix.multiply((new THREE.Matrix4()).makeScale(.5, .5, .5));
		lantern.matrix.copy(matrix);
		scene.add(lantern);

		var animation = new RotationAnimation(lantern, function(angle, time, delta) {
			return Math.sin(time/1000*1.5)*Math.PI/16;
		}, new THREE.Vector3(1, 0, 0));
		animation.begin();

		var angle_max = Math.PI/4;
		var animation2 = new RotationAnimation(lantern, function(angle, time, delta) {
			angle += delta/(1000*1.5);
			if (angle < angle_max) { return angle; }
			else { return angle_max; }
		}, new THREE.Vector3(1, 0, 0));
		animation.chain(animation2);
		animation2.invert();					// note that in theory invert() has the same effect
													// of setVeclocity(-1) if the controller is
													// properly written (negative time), NOT tested
		animation2.begin();						// necessary for setting angle (which is
													// reasonable), see specification
		animation2.setAngle(angle_max);			// set (current) angle because of first inversion
													// in Update()...
		animation2.setInitAngle(-angle_max);	// ...and the initial angle too
		animation2.end();						// necessary to contrast the begin() call

		var wind = false;
		var time = Date.now();

		// } --------------------------------------------------------- wind test
        
        Update();

		
		</script>
	</body>
</html>
